# C1-2018级算法第一次上机

# pair

时间限制: 1000 ms 内存限制: 65536 kb

总通过人数: 124 总提交人数: 136

## 题面

c++中有一个非常方便的结构体pair<type,type>

现在我们定义一个合法的，只有pair和int构成的pair如下：

- 当且仅当type为int或者pair<type,type>时，pair<type,type> 合法

例如pair<int,int>和pair<pair<int,int>,int>是一个合法的pair

现在给你多个pair和int字符串，按照给出pair和int的顺序,添加'<' , '>' , ','这三个符号,使得给出的串成为一个合法的pair<type,type>。（如果没有pair，只有一个int，是不合法的）

如果不行，输出Error occurred

## 输入

第一行一个数字 𝑡t 表示数据组数。

每组数据两行，第一行一个数字 𝑛n 表示字符串个数，第二行 𝑛n 个字符串，只会是pair或者int。

## 输出

一行一个字符串

## 输入样例1

```
3
5
pair pair int int int
2
pair int
1
int
```

## 输出样例1

```
pair<pair<int,int>,int>
Error occurred
Error occurred
```

## 数据范围

1≤𝑡≤1001≤t≤100

0≤𝑛≤1000

## 思路

**这题其实是基于编译原理的语法分析出的一个递归调用问题，感觉上来说，只要是正经的做过编译课设，对这些互相调用的递归函数很熟悉了之后，这种题就随便锤了...**

**放在算法里这应该是纯递归问题的集大成者，确实算得上一道很好的题目了**

那么作为相当老练的编译原理课设选手，我们来分析一下这题...

**实际上需要分析的两个语法成分就是pair类型和type类型**

### pair

**首先第一个词得是pair，然后后面需要两个type类型做支撑，具体pair出来的结果是基础的字符串处理了**

### type

**根据题意，int和pair类型都符合type，所以判断如果是int，则返回正确，如果是type，则开始调用type的检测函数，返回其返回值，都不是则错误**

### 需要注意的错误

- **在做语法检测的时候，什么时候下标该往前挪什么时候不该，需要自己对着样例考虑一下**
- **最后别忘了，最外层的parse pair结果正确还不够，必须实打实地跑完n个单词才行**

